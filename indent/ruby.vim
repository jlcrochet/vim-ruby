" Vim indent file
" Language: Ruby
" Author: Jeffrey Crochet <jlcrochet@hey.com>
" URL: https://github.com/jlcrochet/vim-ruby

if get(b:, "did_indent")
  finish
endif

let b:did_indent = 1

setlocal indentkeys=0),0],0},0.,0=..,0=&.,o,O,!^F
" Generated by tools/indent.rb:
setlocal indentkeys+=0=end,0=enda,0=endb,0=endc,0=endd,0=ende,0=endf,0=endg,0=endh,0=endi,0=endj,0=endk,0=endl,0=endm,0=endn,0=endo,0=endp,0=endq,0=endr,0=ends,0=endt,0=endu,0=endv,0=endw,0=endx,0=endy,0=endz,0=endA,0=endB,0=endC,0=endD,0=endE,0=endF,0=endG,0=endH,0=endI,0=endJ,0=endK,0=endL,0=endM,0=endN,0=endO,0=endP,0=endQ,0=endR,0=endS,0=endT,0=endU,0=endV,0=endW,0=endX,0=endY,0=endZ,0=end1,0=end2,0=end3,0=end4,0=end5,0=end6,0=end7,0=end8,0=end9,0=end0,0=end_,0=end?,0=end!,0=end:,0=else,0=elsea,0=elseb,0=elsec,0=elsed,0=elsee,0=elsef,0=elseg,0=elseh,0=elsei,0=elsej,0=elsek,0=elsel,0=elsem,0=elsen,0=elseo,0=elsep,0=elseq,0=elser,0=elses,0=elset,0=elseu,0=elsev,0=elsew,0=elsex,0=elsey,0=elsez,0=elseA,0=elseB,0=elseC,0=elseD,0=elseE,0=elseF,0=elseG,0=elseH,0=elseI,0=elseJ,0=elseK,0=elseL,0=elseM,0=elseN,0=elseO,0=elseP,0=elseQ,0=elseR,0=elseS,0=elseT,0=elseU,0=elseV,0=elseW,0=elseX,0=elseY,0=elseZ,0=else1,0=else2,0=else3,0=else4,0=else5,0=else6,0=else7,0=else8,0=else9,0=else0,0=else_,0=else?,0=else!,0=else:,0=elsif,0=elsifa,0=elsifb,0=elsifc,0=elsifd,0=elsife,0=elsiff,0=elsifg,0=elsifh,0=elsifi,0=elsifj,0=elsifk,0=elsifl,0=elsifm,0=elsifn,0=elsifo,0=elsifp,0=elsifq,0=elsifr,0=elsifs,0=elsift,0=elsifu,0=elsifv,0=elsifw,0=elsifx,0=elsify,0=elsifz,0=elsifA,0=elsifB,0=elsifC,0=elsifD,0=elsifE,0=elsifF,0=elsifG,0=elsifH,0=elsifI,0=elsifJ,0=elsifK,0=elsifL,0=elsifM,0=elsifN,0=elsifO,0=elsifP,0=elsifQ,0=elsifR,0=elsifS,0=elsifT,0=elsifU,0=elsifV,0=elsifW,0=elsifX,0=elsifY,0=elsifZ,0=elsif1,0=elsif2,0=elsif3,0=elsif4,0=elsif5,0=elsif6,0=elsif7,0=elsif8,0=elsif9,0=elsif0,0=elsif_,0=elsif?,0=elsif!,0=elsif:,0=when,0=whena,0=whenb,0=whenc,0=whend,0=whene,0=whenf,0=wheng,0=whenh,0=wheni,0=whenj,0=whenk,0=whenl,0=whenm,0=whenn,0=wheno,0=whenp,0=whenq,0=whenr,0=whens,0=whent,0=whenu,0=whenv,0=whenw,0=whenx,0=wheny,0=whenz,0=whenA,0=whenB,0=whenC,0=whenD,0=whenE,0=whenF,0=whenG,0=whenH,0=whenI,0=whenJ,0=whenK,0=whenL,0=whenM,0=whenN,0=whenO,0=whenP,0=whenQ,0=whenR,0=whenS,0=whenT,0=whenU,0=whenV,0=whenW,0=whenX,0=whenY,0=whenZ,0=when1,0=when2,0=when3,0=when4,0=when5,0=when6,0=when7,0=when8,0=when9,0=when0,0=when_,0=when?,0=when!,0=when:,0=in,0=ina,0=inb,0=inc,0=ind,0=ine,0=inf,0=ing,0=inh,0=ini,0=inj,0=ink,0=inl,0=inm,0=inn,0=ino,0=inp,0=inq,0=inr,0=ins,0=int,0=inu,0=inv,0=inw,0=inx,0=iny,0=inz,0=inA,0=inB,0=inC,0=inD,0=inE,0=inF,0=inG,0=inH,0=inI,0=inJ,0=inK,0=inL,0=inM,0=inN,0=inO,0=inP,0=inQ,0=inR,0=inS,0=inT,0=inU,0=inV,0=inW,0=inX,0=inY,0=inZ,0=in1,0=in2,0=in3,0=in4,0=in5,0=in6,0=in7,0=in8,0=in9,0=in0,0=in_,0=in?,0=in!,0=in:,0=rescue,0=rescuea,0=rescueb,0=rescuec,0=rescued,0=rescuee,0=rescuef,0=rescueg,0=rescueh,0=rescuei,0=rescuej,0=rescuek,0=rescuel,0=rescuem,0=rescuen,0=rescueo,0=rescuep,0=rescueq,0=rescuer,0=rescues,0=rescuet,0=rescueu,0=rescuev,0=rescuew,0=rescuex,0=rescuey,0=rescuez,0=rescueA,0=rescueB,0=rescueC,0=rescueD,0=rescueE,0=rescueF,0=rescueG,0=rescueH,0=rescueI,0=rescueJ,0=rescueK,0=rescueL,0=rescueM,0=rescueN,0=rescueO,0=rescueP,0=rescueQ,0=rescueR,0=rescueS,0=rescueT,0=rescueU,0=rescueV,0=rescueW,0=rescueX,0=rescueY,0=rescueZ,0=rescue1,0=rescue2,0=rescue3,0=rescue4,0=rescue5,0=rescue6,0=rescue7,0=rescue8,0=rescue9,0=rescue0,0=rescue_,0=rescue?,0=rescue!,0=rescue:,0=ensure,0=ensurea,0=ensureb,0=ensurec,0=ensured,0=ensuree,0=ensuref,0=ensureg,0=ensureh,0=ensurei,0=ensurej,0=ensurek,0=ensurel,0=ensurem,0=ensuren,0=ensureo,0=ensurep,0=ensureq,0=ensurer,0=ensures,0=ensuret,0=ensureu,0=ensurev,0=ensurew,0=ensurex,0=ensurey,0=ensurez,0=ensureA,0=ensureB,0=ensureC,0=ensureD,0=ensureE,0=ensureF,0=ensureG,0=ensureH,0=ensureI,0=ensureJ,0=ensureK,0=ensureL,0=ensureM,0=ensureN,0=ensureO,0=ensureP,0=ensureQ,0=ensureR,0=ensureS,0=ensureT,0=ensureU,0=ensureV,0=ensureW,0=ensureX,0=ensureY,0=ensureZ,0=ensure1,0=ensure2,0=ensure3,0=ensure4,0=ensure5,0=ensure6,0=ensure7,0=ensure8,0=ensure9,0=ensure0,0=ensure_,0=ensure?,0=ensure!,0=ensure:,0==begin,0==begina,0==beginb,0==beginc,0==begind,0==begine,0==beginf,0==beging,0==beginh,0==begini,0==beginj,0==begink,0==beginl,0==beginm,0==beginn,0==begino,0==beginp,0==beginq,0==beginr,0==begins,0==begint,0==beginu,0==beginv,0==beginw,0==beginx,0==beginy,0==beginz,0==beginA,0==beginB,0==beginC,0==beginD,0==beginE,0==beginF,0==beginG,0==beginH,0==beginI,0==beginJ,0==beginK,0==beginL,0==beginM,0==beginN,0==beginO,0==beginP,0==beginQ,0==beginR,0==beginS,0==beginT,0==beginU,0==beginV,0==beginW,0==beginX,0==beginY,0==beginZ,0==begin1,0==begin2,0==begin3,0==begin4,0==begin5,0==begin6,0==begin7,0==begin8,0==begin9,0==begin0,0==begin_,0==begin?,0==begin!,0==begin:,0==end,0==enda,0==endb,0==endc,0==endd,0==ende,0==endf,0==endg,0==endh,0==endi,0==endj,0==endk,0==endl,0==endm,0==endn,0==endo,0==endp,0==endq,0==endr,0==ends,0==endt,0==endu,0==endv,0==endw,0==endx,0==endy,0==endz,0==endA,0==endB,0==endC,0==endD,0==endE,0==endF,0==endG,0==endH,0==endI,0==endJ,0==endK,0==endL,0==endM,0==endN,0==endO,0==endP,0==endQ,0==endR,0==endS,0==endT,0==endU,0==endV,0==endW,0==endX,0==endY,0==endZ,0==end1,0==end2,0==end3,0==end4,0==end5,0==end6,0==end7,0==end8,0==end9,0==end0,0==end_,0==end?,0==end!,0==end:

if has("nvim-0.5")
  lua require "get_ruby_indent"
  setlocal indentexpr=v:lua.get_ruby_indent()
  finish
endif

setlocal indentexpr=GetRubyIndent()

if exists("*GetRubyIndent")
  finish
endif

" Helpers {{{
let s:multiline_regions = #{
      \ rubyComment: 1,
      \ rubyString: 1,
      \ rubyStringEscape: 1,
      \ rubyStringInterpolationDelimiter: 1,
      \ rubyStringParenthesisEscape: 1,
      \ rubyStringSquareBracketEscape: 1,
      \ rubyStringCurlyBraceEscape: 1,
      \ rubyStringAngleBracketEscape: 1,
      \ rubyStringEnd: 1,
      \ rubyArrayEscape: 1,
      \ rubySymbol: 1,
      \ rubySymbolEnd: 1,
      \ rubyRegex: 1,
      \ rubyRegexEnd: 1,
      \ rubyRegexSlashEscape: 1,
      \ rubyOnigmoEscape: 1,
      \ rubyOnigmoGroup: 1,
      \ rubyOnigmoMetaCharacter: 1,
      \ rubyOnigmoQuantifier: 1,
      \ rubyOnigmoComment: 1,
      \ rubyOnigmoClass: 1,
      \ rubyOnigmoPOSIXClass: 1,
      \ rubyOnigmoIntersection: 1,
      \ rubyCommand: 1,
      \ rubyCommandEnd: 1,
      \ rubyHeredocLine: 1,
      \ rubyHeredocLineRaw: 1,
      \ rubyHeredocEnd: 1
      \ }

let s:block_start_re = '\C\v<%(if|unless|case|begin|for|while|until|do)>'
let s:block_middle_re = '\C\v<%(else|elsif|when|ensure|in|rescue)>'

let s:define_block_start_re = '\C\v<%(def|class|module)>'
let s:define_block_middle_re = '\C\v<%(else|ensure|rescue)>'

let s:all_start_re = '\C\v<%(if|unless|case|begin|for|while|until|do|def|class|module)>'

let s:skip_bracket = 'synID(line("."), col("."), 0)->synIDattr("name") !~# ''^ruby\%(StringArray\|SymbolArray\)\=Delimiter$'''
let s:skip_keyword = 'synID(line("."), col("."), 0)->synIDattr("name") !=# "rubyKeyword"'
let s:skip_define = 'synID(line("."), col("."), 0)->synIDattr("name") !=# "rubyDefine"'
let s:skip_all = 'synID(line("."), col("."), 0)->synIDattr("name") !~# ''^ruby\%(Keyword\|Define\)$'''

function s:skip_keyword_simple_func()
  let [l, c] = [line("."), col(".")]

  if synID(l, c, 0)->synIDattr("name") !=# "rubyKeyword"
    return 1
  endif

  if expand("<cword>") ==# "def"
    " Check for an "endless" definition:
    let [l, c] = searchpos('=[=>~]\@!', "z", l)

    while l
      if synID(l, c, 0)->synIDattr("name") ==# "rubyMethodAssignmentOperator"
        return 1
      endif

      let [l, c] = searchpos('=[=>~]\@!', "z", l)
    endwhile
  endif
endfunction

let s:skip_keyword_simple = function("s:skip_keyword_simple_func")

function s:is_operator(char, idx, lnum)
  if a:char =~# '[%&*+\-/:<>?^|~]'
    return synID(a:lnum, a:idx + 1, 0)->synIDattr("name") ==# "rubyOperator"
  elseif a:char ==# "="
    return synID(a:lnum, a:idx + 1, 0)->synIDattr("name") =~# '^ruby\%(MethodAssignment\)\=Operator$'
  endif
endfunction

" 0 = no continuation
" 1 = hanging operator or backslash
" 2 = hanging postfix keyword
" 3 = comma
" 4 = opening bracket
" 5 = hash key delimiter
function s:ends_with_line_continuator(lnum)
  let line = getline(a:lnum)
  let [char, idx, next_idx] = line->matchstrpos('\S')

  let last_idx = idx

  while idx != -1
    if char ==# "#"
      if synID(a:lnum, next_idx, 0)->synIDattr("name") ==# "rubyLineComment"
        break
      endif
    else
      let [word, _, offset] = line->matchstrpos('^\l\+', idx)

      if offset != -1
        let next_idx = offset
      endif
    endif

    let last_idx = idx

    let [char, idx, next_idx] = line->matchstrpos('\S', next_idx)
  endwhile

  let last_char = line[last_idx]

  if last_char ==# '\'
    if synID(a:lnum, last_idx + 1, 0)->synIDattr("name") ==# "rubyBackslash"
      return 1
    endif
  elseif last_char ==# ","
    if synID(a:lnum, last_idx + 1, 0)->synIDattr("name") ==# "rubyComma"
      return 3
    endif
  elseif last_char ==# ":"
    let syngroup = synID(a:lnum, last_idx + 1, 0)->synIDattr("name")

    if syngroup ==# "rubyOperator"
      return 1
    elseif syngroup ==# "rubySymbolStart"
      return 5
    endif
  elseif last_char ==# "(" || last_char ==# "[" || last_char ==# "{"
    if synID(a:lnum, last_idx + 1, 0)->synIDattr("name") =~# '^ruby\%(StringArray\|SymbolArray\)\=Delimiter$'
      return 4
    endif
  elseif last_char ==# "|"
    let syngroup = synID(a:lnum, last_idx + 1, 0)->synIDattr("name")

    if syngroup ==# "rubyOperator"
      return 1
    elseif syngroup ==# "rubyDelimiter"
      return 4
    endif
  elseif last_char ==# "a"
    if line->match('\C^and[[:alnum:]_?!:]\@!', last_idx) != -1
      return 2
    endif
  elseif last_char ==# "i"
    if line->match('\C^i[fn][[:alnum:]_?!:]\@!', last_idx) != -1
      return 2
    endif
  elseif last_char ==# "n"
    if line->match('\C^not[[:alnum:]_?!:]\@!', last_idx) != -1
      return 2
    endif
  elseif last_char ==# "o"
    if line->match('\C^or[[:alnum:]_?!:]\@!', last_idx) != -1
      return 2
    endif
  elseif last_char ==# "r"
    if line->match('\C^rescue[[:alnum:]_?!:]\@!', last_idx) != -1 && synID(a:lnum, last_idx + 1, 0)->synIDattr("name") ==# "rubyPostfixKeyword"
      return 2
    endif
  elseif last_char ==# "u"
    if line->match('\C^un\%(less\|til\)[[:alnum:]_?!:]\@!', last_idx) != -1
      return 2
    endif
  elseif last_char ==# "w"
    if line->match('\C^while[[:alnum:]_?!:]\@!', last_idx) != -1
      return 2
    endif
  elseif s:is_operator(last_char, last_idx, a:lnum)
    return 1
  endif
endfunction

function s:get_msl(lnum)
  let prev_lnum = prevnonblank(a:lnum - 1)

  if prev_lnum == 0
    return a:lnum
  endif

  let start_lnum = prev_lnum

  while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
    let start_lnum = prevnonblank(start_lnum - 1)
  endwhile

  let continuation = 0

  let start_line = getline(start_lnum)
  let [start_first_char, start_first_idx, start_first_col] = start_line->matchstrpos('\S')

  if start_first_char ==# "&"
    if start_line[start_first_col] ==# "."
      let continuation = 6
    endif
  elseif start_first_char ==# "."
    if start_line[start_first_col] !=# "."
      let continuation = 6
    endif
  endif

  let prev_lnum = prevnonblank(start_lnum - 1)

  if prev_lnum == 0
    return start_lnum
  endif

  if !continuation
    let continuation = s:ends_with_line_continuator(prev_lnum)

    if continuation == 4
      return start_lnum
    endif
  endif

  while continuation
    let start_lnum = prev_lnum

    while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
      let start_lnum = prevnonblank(start_lnum - 1)
    endwhile

    let continuation = 0

    let start_line = getline(start_lnum)
    let [start_first_char, start_first_idx, start_first_col] = start_line->matchstrpos('\S')

    if start_first_char ==# "&"
      if start_line[start_first_col] ==# "."
        let continuation = 6
      endif
    elseif start_first_char ==# "."
      if start_line[start_first_col] !=# "."
        let continuation = 6
      endif
    endif

    let prev_lnum = prevnonblank(start_lnum - 1)

    if prev_lnum == 0
      return start_lnum
    endif

    if !continuation
      let continuation = s:ends_with_line_continuator(prev_lnum)

      if continuation == 4
        return start_lnum
      endif
    endif
  endwhile

  return start_lnum
endfunction
" }}}

if get(g:, "ruby_simple_indent")
  " Simple {{{
  function GetRubyIndent() abort
    let syngroup = synID(v:lnum, 1, 0)->synIDattr("name")

    if syngroup ==# "rubyComment"
      " Check to see if this line is the `=end` of a block comment:
      if getline(v:lnum) =~# '^\s*=end\>'
        return 0
      else
        return -1
      endif
    endif

    if s:multiline_regions->get(syngroup)
      return -1
    endif

    let prev_lnum = prevnonblank(v:lnum - 1)

    if prev_lnum == 0
      return 0
    endif

    " Check the current line for a closing bracket or dedenting keyword:
    let line = getline(v:lnum)
    let [first_char, first_idx, first_col] = line->matchstrpos('\S')

    if line->match('\C^=begin\>', first_idx) != -1
      return 0
    endif

    let shift = 0
    let has_dedent = 0
    let continuation = 0

    if first_char ==# ")" || first_char ==# "]" || first_char ==# "}"
      let shift -= 1
      let has_dedent = 1
    elseif first_char ==# "&"
      if line[first_col] ==# "."
        let continuation = 6
      endif
    elseif first_char ==# "."
      if line[first_col] !=# "."
        let continuation = 6
      endif
    elseif line->match('\C^\%(end\|else\|elsif\|when\|in\|rescue\|ensure\)[[:alnum:]_?!:]\@!', first_idx) != -1
      let shift -= 1
      let has_dedent = 1
    endif

    " Check the previous line:
    let start_lnum = prev_lnum

    while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
      let start_lnum = prevnonblank(start_lnum - 1)
    endwhile

    if !continuation
      let continuation = s:ends_with_line_continuator(prev_lnum)

      if continuation == 4
        let shift += 1
        return indent(start_lnum) + shift * shiftwidth()
      endif
    endif

    call cursor(0, 1)

    if searchpair(s:all_start_re, s:block_middle_re, '\C\<end\>', "b", s:skip_keyword_simple, start_lnum)
      let shift += 1
      return indent(start_lnum) + shift * shiftwidth()
    endif

    " Check for line continuations:
    let prev_continuation = 0

    let start_line = getline(start_lnum)
    let [start_first_char, start_first_idx, start_first_col] = start_line->matchstrpos('\S')

    if start_first_char ==# "&"
      if start_line[start_first_col] ==# "."
        let prev_continuation = 6
      endif
    elseif start_first_char ==# "."
      if start_line[start_first_col] !=# "."
        let prev_continuation = 6
      endif
    endif

    if !prev_continuation
      let prev_lnum = prevnonblank(start_lnum - 1)

      if prev_lnum != 0
        let prev_continuation = s:ends_with_line_continuator(prev_lnum)
      endif
    endif

    if continuation == 0
      if prev_continuation == 1 || prev_continuation == 2 || prev_continuation == 6
        let shift -= 1
      elseif prev_continuation == 3
        if !has_dedent && start_line->match('\C^\%([)\]}]\|end[[:alnum:]_?!:]\@!\)', start_first_idx) == -1
          let shift -= 1
        endif
      endif
    elseif continuation == 1 || continuation == 2 || continuation == 6
      if prev_continuation == 1 || prev_continuation == 2 || prev_continuation == 5 || prev_continuation == 6
        return start_first_idx
      else
        return start_first_idx + shiftwidth()
      endif
    elseif continuation == 3
      if prev_continuation == 1 || prev_continuation == 2
        let shift -= 1
      elseif prev_continuation == 3
        if has_dedent
          return start_first_idx - shiftwidth()
        else
          return start_first_idx
        endif
      elseif prev_continuation == 4
        return start_first_idx
      elseif prev_continuation == 5
        return start_first_idx - shiftwidth()
      else
        if start_line->match('\C^\%([)\]}]\|end[[:alnum:]_?!:]\@!\)', start_first_idx) == -1
          return start_first_idx + shiftwidth()
        endif
      endif
    elseif continuation == 5
      return start_first_idx + shiftwidth()
    endif

    " Default:
    return start_first_idx + shift * shiftwidth()
  endfunction
  " }}}
else
  " Default {{{
  function GetRubyIndent() abort
    let syngroup = synID(v:lnum, 1, 0)->synIDattr("name")

    if syngroup ==# "rubyComment"
      " Check to see if this line is the `=end` of a block comment:
      if getline(v:lnum) =~# '^\s*=end\>'
        return 0
      else
        return -1
      endif
    endif

    if s:multiline_regions->get(syngroup)
      return -1
    endif

    let prev_lnum = prevnonblank(v:lnum - 1)

    if prev_lnum == 0
      return 0
    endif

    " Check the current line for a closing bracket or dedenting keyword:
    let line = getline(v:lnum)
    let [first_char, first_idx, first_col] = line->matchstrpos('\S')

    if line->match('\C^=begin\>', first_idx) != -1
      return 0
    endif

    call cursor(0, 1)

    if first_char ==# ")"
      return indent(searchpair('(', '', ')', "bW", s:skip_bracket))
    elseif first_char ==# "]"
      return indent(searchpair('\[', '', ']', "bW", s:skip_bracket))
    elseif first_char ==# "}"
      return indent(searchpair('{', '', '}', "bW", s:skip_bracket))
    elseif line->match('\C^\%(end\|else\|elsif\|when\|in\|rescue\|ensure\)[[:alnum:]_?!:]\@!', first_idx) != -1
      let syngroup = synID(v:lnum, first_col, 0)->synIDattr("name")

      if syngroup ==# "rubyKeyword"
        let [l, c] = searchpairpos(s:block_start_re, s:block_middle_re, '\C\<end\>', "bW", s:skip_keyword)

        if expand("<cword>") ==# "do"
          return indent(l)
        else
          return c - 1
        endif
      elseif syngroup ==# "rubyDefine"
        let shift = -1
        let msl = s:get_msl(v:lnum)

        if searchpair(s:define_block_start_re, s:define_block_middle_re, '\C\<end\>', "b", s:skip_define, msl)
          let shift += 1
        endif

        return indent(msl) + shift * shiftwidth()
      endif
    endif

    " Check the previous line:
    let start_lnum = prev_lnum

    while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
      let start_lnum = prevnonblank(start_lnum - 1)
    endwhile

    let [l, c, p] = searchpos('\C\([(\[{]\)\|\([)\]}]\)\|\v<%((def|class|module)|(if|unless|case|begin|while|until|for|do)|(else|elsif|when|in|ensure|rescue)|(end))>', "bp", start_lnum)

    while p
      let syngroup = synID(l, c, 0)->synIDattr("name")

      if p == 2
        if syngroup ==# "rubyDelimiter"
          let line = getline(l)
          let [char, idx, _] = line->matchstrpos('\S', c)

          if char ==# "|" || char ==# "#"
            return indent(l) + shiftwidth()
          else
            return idx
          endif
        elseif syngroup ==# "rubyStringArrayDelimiter" || syngroup ==# "rubySymbolArrayDelimiter"
          if search('\S', "z", l)
            return col(".") - 1
          else
            return indent(l) + shiftwidth()
          endif
        endif
      elseif p == 3
        if syngroup ==# "rubyDelimiter" || syngroup ==# "rubyStringArrayDelimiter" || syngroup ==# "rubySymbolArrayDelimiter"
          let start_lnum = searchpair('[(\[{]', '', '[)\]}]', "bW", s:skip_bracket)

          while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
            let start_lnum = prevnonblank(start_lnum - 1)
          endwhile
        endif
      elseif p == 4
        if syngroup ==# "rubyDefine"
          return indent(l) + shiftwidth()
        endif
      elseif p == 5
        if syngroup ==# "rubyKeyword"
          if expand("<cword>") ==# "do"
            return indent(l) + shiftwidth()
          else
            return c - 1 + shiftwidth()
          endif
        endif
      elseif p == 6
        if syngroup ==# "rubyKeyword" || syngroup ==# "rubyDefine"
          return c - 1 + shiftwidth()
        endif
      elseif p == 7
        if syngroup ==# "rubyKeyword"
          let start_lnum = searchpair(s:block_start_re, '', '\C\<end\>', "bW", s:skip_keyword)

          while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
            let start_lnum = prevnonblank(start_lnum - 1)
          endwhile
        elseif syngroup ==# "rubyDefine"
          let start_lnum = searchpair(s:define_block_start_re, '', '\C\<end\>', "bW", s:skip_define)

          while s:multiline_regions->get(synID(start_lnum, 1, 0)->synIDattr("name"))
            let start_lnum = prevnonblank(start_lnum - 1)
          endwhile
        endif
      endif

      let [l, c, p] = searchpos('\C\([(\[{]\)\|\([)\]}]\)\|\v<%((def|class|module)|(if|unless|case|begin|while|until|for|do)|(else|elsif|when|in|ensure|rescue)|(end))>', "bp", start_lnum)
    endwhile

    " Check for line continuations:
    " 0 = no continuation
    " 1 = hanging operator or backslash
    " 2 = hanging postfix keyword
    " 3 = comma
    " 4 = opening bracket
    " 5 = hash key delimiter
    " 6 = leading dot
    let continuation = 0

    if first_char ==# "&"
      if line[first_col] ==# "."
        let continuation = 6
      endif
    elseif first_char ==# "."
      if line[first_col] !=# "."
        let continuation = 6
      endif
    endif

    if !continuation
      let continuation = s:ends_with_line_continuator(prev_lnum)
    endif

    let prev_continuation = 0

    let start_line = getline(start_lnum)
    let [start_first_char, start_first_idx, start_first_col] = start_line->matchstrpos('\S')

    if start_first_char ==# "&"
      if start_line[start_first_col] ==# "."
        let prev_continuation = 6
      endif
    elseif start_first_char ==# "."
      if start_line[start_first_col] !=# "."
        let prev_continuation = 6
      endif
    endif

    if !prev_continuation
      let prev_prev_lnum = prevnonblank(start_lnum - 1)

      if prev_prev_lnum > 0
        let prev_continuation = s:ends_with_line_continuator(prev_prev_lnum)
      endif
    endif

    if continuation == 0
      if prev_continuation == 1 || prev_continuation == 3 || prev_continuation == 6
        return indent(s:get_msl(start_lnum))
      elseif prev_continuation == 2
        return start_first_idx - shiftwidth()
      endif
    elseif continuation == 1
      if prev_continuation == 1 || prev_continuation == 5
        return start_first_idx
      else
        " Align with the first character after the first operator in the
        " starting line, if any:
        let upper = strlen(start_line) - 1

        for i in range(start_first_idx + 1, upper)
          let char = start_line[i]

          if char ==# " " || char ==# "\t"
            continue
          endif

          if s:is_operator(char, i, start_lnum)
            for j in range(i + 1, upper)
              let char = start_line[j]

              if char ==# " " || char ==# "\t"
                continue
              endif

              if !s:is_operator(char, j, start_lnum)
                return j
              endif
            endfor

            break
          endif
        endfor

        return start_first_idx + shiftwidth()
      endif
    elseif continuation == 2
      if prev_continuation == 1 || prev_continuation == 2 || prev_continuation == 5
        return start_first_idx
      else
        return start_first_idx + shiftwidth()
      endif
    elseif continuation == 3
      if prev_continuation == 1
        return indent(s:get_msl(start_lnum))
      elseif prev_continuation == 2 || prev_continuation == 5
        return start_first_idx - shiftwidth()
      elseif prev_continuation == 3 || prev_continuation == 4
        return start_first_idx
      else
        return start_first_idx + shiftwidth()
      endif
    elseif continuation == 5
      return start_first_idx + shiftwidth()
    elseif continuation == 6
      if prev_continuation == 6
        return start_first_idx
      else
        " Align with the first dot in the starting line, if any:
        let idx = stridx(start_line, ".", start_first_idx + 1)

        while idx != -1
          if synID(start_lnum, idx + 1, 0)->synIDattr("name") ==# "rubyMethodOperator"
            if start_line[idx - 1] ==# "&"
              return idx - 1
            else
              return idx
            endif
          endif

          let idx = stridx(start_line, ".", idx + 2)
        endwhile

        return start_first_idx + shiftwidth()
      endif
    endif

    " Default:
    return start_first_idx
  endfunction
  " }}}
endif

" vim:fdm=marker:mmp=100000
